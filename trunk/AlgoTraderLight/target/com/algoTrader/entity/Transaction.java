// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: HibernateEntity.vsl in andromda-hibernate-cartridge.
//
package com.algoTrader.entity;

/**
 * 
 */
public abstract class Transaction
        extends com.algoTrader.BaseObject
        implements java.io.Serializable {
	/**
	 * The serial version UID of this class. Needed for serialization.
	 */
	private static final long	serialVersionUID	= 8737214988760808079L;
	
	private java.util.Date	  dateTime;
	
	/**
     * 
     */
	public java.util.Date getDateTime() {
		return dateTime;
	}
	
	public void setDateTime(final java.util.Date dateTime) {
		this.dateTime = dateTime;
	}
	
	private long	quantity;
	
	/**
	 * <p>
	 * BUY: pos
	 * </p>
	 * <p>
	 * SELL: neg
	 * </p>
	 * <p>
	 * CREDIT: 1
	 * </p>
	 * <p>
	 * DEBIT: 1
	 * </p>
	 * <p>
	 * INTREST: 1
	 * </p>
	 * <p>
	 * FEES: 1
	 * </p>
	 * <p>
	 * REBALANCE remove: neg
	 * </p>
	 * <p>
	 * REBALANCE add: pos
	 * </p>
	 */
	public long getQuantity() {
		return quantity;
	}
	
	public void setQuantity(final long quantity) {
		this.quantity = quantity;
	}
	
	private java.math.BigDecimal	price;
	
	/**
	 * <p>
	 * allways positive
	 * </p>
	 */
	public java.math.BigDecimal getPrice() {
		return price;
	}
	
	public void setPrice(final java.math.BigDecimal price) {
		this.price = price;
	}
	
	private java.math.BigDecimal	commission;
	
	/**
     * 
     */
	public java.math.BigDecimal getCommission() {
		return commission;
	}
	
	public void setCommission(final java.math.BigDecimal commission) {
		this.commission = commission;
	}
	
	private com.algoTrader.enumeration.Currency	currency;
	
	/**
     * 
     */
	public com.algoTrader.enumeration.Currency getCurrency() {
		return currency;
	}
	
	public void setCurrency(final com.algoTrader.enumeration.Currency currency) {
		this.currency = currency;
	}
	
	private com.algoTrader.enumeration.TransactionType	type;
	
	/**
     * 
     */
	public com.algoTrader.enumeration.TransactionType getType() {
		return type;
	}
	
	public void setType(final com.algoTrader.enumeration.TransactionType type) {
		this.type = type;
	}
	
	private int	id;
	
	/**
     * 
     */
	public int getId() {
		return id;
	}
	
	public void setId(final int id) {
		this.id = id;
	}
	
	private com.algoTrader.entity.Security	security;
	
	/**
     * 
     */
	public com.algoTrader.entity.Security getSecurity() {
		return security;
	}
	
	public void setSecurity(final com.algoTrader.entity.Security security) {
		this.security = security;
	}
	
	private com.algoTrader.entity.Strategy	strategy;
	
	/**
     * 
     */
	public com.algoTrader.entity.Strategy getStrategy() {
		return strategy;
	}
	
	public void setStrategy(final com.algoTrader.entity.Strategy strategy) {
		this.strategy = strategy;
	}
	
	private com.algoTrader.entity.Position	position;
	
	/**
     * 
     */
	public com.algoTrader.entity.Position getPosition() {
		return position;
	}
	
	public void setPosition(final com.algoTrader.entity.Position position) {
		this.position = position;
	}
	
	/**
     * 
     */
	public abstract java.math.BigDecimal getValue();
	
	/**
     * 
     */
	public abstract double getValueDouble();
	
	/**
	 * Returns <code>true</code> if the argument is an Transaction instance and
	 * all identifiers for this entity
	 * equal the identifiers of the argument entity. Returns <code>false</code>
	 * otherwise.
	 */
	@Override
	public boolean equals(final Object object) {
		if (this == object) { return true; }
		if (!(object instanceof Transaction)) { return false; }
		final Transaction that = (Transaction) object;
		if (id != that.getId()) { return false; }
		return true;
	}
	
	/**
	 * Returns a hash code based on this entity's identifiers.
	 */
	@Override
	public int hashCode() {
		int hashCode = 0;
		hashCode = 29 * hashCode + id;
		
		return hashCode;
	}
	
	/**
	 * Constructs new instances of {@link com.algoTrader.entity.Transaction}.
	 */
	public static final class Factory {
		/**
		 * Constructs a new instance of
		 * {@link com.algoTrader.entity.Transaction}.
		 */
		public static com.algoTrader.entity.Transaction newInstance() {
			return new com.algoTrader.entity.TransactionImpl();
		}
		
		/**
		 * Constructs a new instance of
		 * {@link com.algoTrader.entity.Transaction}, taking all required and/or
		 * read-only properties as arguments.
		 */
		public static com.algoTrader.entity.Transaction newInstance(
		        final java.util.Date dateTime, final long quantity,
		        final java.math.BigDecimal price,
		        final com.algoTrader.enumeration.Currency currency,
		        final com.algoTrader.enumeration.TransactionType type) {
			final com.algoTrader.entity.Transaction entity = new com.algoTrader.entity.TransactionImpl();
			entity.setDateTime(dateTime);
			entity.setQuantity(quantity);
			entity.setPrice(price);
			entity.setCurrency(currency);
			entity.setType(type);
			return entity;
		}
		
		/**
		 * Constructs a new instance of
		 * {@link com.algoTrader.entity.Transaction}, taking all possible
		 * properties
		 * (except the identifier(s))as arguments.
		 */
		public static com.algoTrader.entity.Transaction newInstance(
		        final java.util.Date dateTime, final long quantity,
		        final java.math.BigDecimal price,
		        final java.math.BigDecimal commission,
		        final com.algoTrader.enumeration.Currency currency,
		        final com.algoTrader.enumeration.TransactionType type,
		        final com.algoTrader.entity.Security security,
		        final com.algoTrader.entity.Strategy strategy,
		        final com.algoTrader.entity.Position position) {
			final com.algoTrader.entity.Transaction entity = new com.algoTrader.entity.TransactionImpl();
			entity.setDateTime(dateTime);
			entity.setQuantity(quantity);
			entity.setPrice(price);
			entity.setCommission(commission);
			entity.setCurrency(currency);
			entity.setType(type);
			entity.setSecurity(security);
			entity.setStrategy(strategy);
			entity.setPosition(position);
			return entity;
		}
	}
	
	// HibernateEntity.vsl merge-point
}